

AFTivIPCWScorePreKM <- function(beta, data.simu, GC)
{ 
  if (class(data.simu) != "survival.data") {stop("Need to use data generated by simIVMultivarSurvivalData")}
  
  #the score function for the AFT model with instrumental variables and Inverse Probability Censoring Weighting
  survival <- data.simu$survival
  X <- data.simu$X
  Z <- data.simu$Z
  n <- nrow(X)
  nvars <- ncol(X)
  
  #transform to log-time
  tt <- log(survival$t)
  
  #creates G_c(T_i) term in the IPCW estimating equation
  GCT <- GC( survival$t )
  
  bX <- X %*% beta
  
  #store the T_i - bX_i term (error)
  err = survival$t - bX
  
  
  
  #sort according to error size ####observed failure time 
  #data.simu <- data.simu[order(data.simu$X),]  
  order.idx <- order(err)
  survival <- survival[order.idx,]
  tt <- tt[order.idx]
  bX <- bX[order.idx]
  err <- err[order.idx]
  X <- as.matrix(X[order.idx,])
  Z <- as.matrix(Z[order.idx,]) 
  
  
  #create indicator to set to zero terms where GCT == 0 and 
  #set to 1 so no dividing by zero occurs
  zero.indicator <- 1 * (GCT != 0)
  GCT[which(GCT == 0)] <- 1
  
  #first col is as.risk.terms, remaining are at.risk.Z.terms
  at.risk.mat <- genIPCWNumDenomMultivar2(bX, Z, err, GC)
  
  #generate empty vector to return eventually
  ret.vec <- numeric(nvars)
  for (i in 1:nvars) {
    #return the score   
    ret.vec[i] <- sum(zero.indicator * (survival$delta / GCT) * (at.risk.mat[,1] * Z[,i] - at.risk.mat[,i + 1])) / sqrt(n)
  }
  
  ret.vec
  
}


AFTScorePre <- function(beta, survival, X, ZXmat, multiplier.wts = NULL)
{ 
  #the score function for the AFT model
  
  n <- nrow(X)
  if (!is.null(multiplier.wts)) {
    stopifnot(length(multiplier.wts) == n)
  }
  nvars <- ncol(X)
  
  #transform to log-time
  if (is.null(survival$log.t)) {survival$log.t <- log(survival$t)}
  
  #store the T_i - bX_i term (error)
  survival$err = survival$log.t - X %*% beta
  
  #sort according to error size ####observed failure time 
  #data.simu <- data.simu[order(data.simu$X),]  
  order.idx <- order(survival$err)
  survival <- survival[order.idx,] 
  X <- as.matrix(X[order.idx,]) 
  
  #the denominator of the at-risk comparison term  
  at.risk.terms <- n:1 / n
  
  ret.vec <- numeric(nvars)
  if (!is.null(multiplier.wts)) {
    for (i in 1:nvars) {
      # multiply by weights  
      Xm <- X[,i] * multiplier.wts
      
      #the numerator of the at-risk comparison term
      at.risk.Z.terms <- cumsumRev(Xm) / n
      
      #return the score   
      ret.vec[i] <- sum(survival$delta * (at.risk.terms * Xm - at.risk.Z.terms)) / sqrt(n)
    }  
  } else {
    for (i in 1:nvars) {
      #the numerator of the at-risk comparison term  
      at.risk.Z.terms <- cumsumRev(X[,i]) / n
      
      #return the score   
      ret.vec[i] <- sum(survival$delta * (at.risk.terms * (X[,i]) - at.risk.Z.terms)) / sqrt(n)
    }  
  }
  ret.vec
}

attr(AFTScorePre, "name") <- "AFTScorePre"



AFTivScorePre <- function(beta, survival, X, ZXmat, multiplier.wts = NULL)
{ 
  #the score function for the AFT model
  
  n <- nrow(X)
  if (!is.null(multiplier.wts)) {
    stopifnot(length(multiplier.wts) == n)
  }
  nvars <- ncol(X)
  
  #transform to log-time
  if (is.null(survival$log.t)) {survival$log.t <- log(survival$t)}
  
  #store the T_i - bX_i term (error)
  survival$err = survival$log.t - X %*% beta
  
  #sort according to error size ####observed failure time 
  #data.simu <- data.simu[order(data.simu$X),]  
  order.idx <- order(survival$err)
  survival <- survival[order.idx,] 
  X <- as.matrix(X[order.idx,])
  ZXmat <- as.matrix(ZXmat[order.idx,]) 
  
  #the denominator of the at-risk comparison term  
  at.risk.terms <- n:1 / n
  
  ret.vec <- numeric(nvars)
  if (is.null(multiplier.wts)) {
    for (i in 1:nvars) {
      #the numerator of the at-risk comparison term  
      at.risk.Z.terms <- cumsumRev(ZXmat[,i]) / n
      
      #return the score   
      ret.vec[i] <- sum(survival$delta * (at.risk.terms * ZXmat[,i] - at.risk.Z.terms)) / sqrt(n)
    }  
  } else {
    for (i in 1:nvars) {
      
      ZXm <- ZXmat[,i] * multiplier.wts
      
      #the numerator of the at-risk comparison term  
      at.risk.Z.terms <- cumsumRev(ZXm) / n
      
      #return the score   
      ret.vec[i] <- sum(survival$delta * (at.risk.terms * ZXm - at.risk.Z.terms)) / sqrt(n)
    }   
  }
  ret.vec
}
attr(AFTivScorePre, "name") <- "AFTivScorePre"

AFTivIPCWScorePre <- function(beta, survival, X, ZXmat, GC, multiplier.wts = NULL)
{ 
  
  #the score function for the AFT model with instrumental variables and Inverse Probability Censoring Weighting
  n <- nrow(X)
  if (!is.null(multiplier.wts)) {
    stopifnot(length(multiplier.wts) == n)
  }
  nvars <- ncol(X)
  
  #transform to log-time
  if (is.null(survival$log.t)) {survival$log.t <- log(survival$t)}
  
  #creates G_c(T_i) term in the IPCW estimating equation
  survival$GCT <- GC(survival$t)
  
  #store the T_i - bX_i term (error)
  survival$err = survival$log.t - X %*% beta
  
  survival$bX <- X %*% beta
  
  #sort according to error size ####observed failure time 
  #data.simu <- data.simu[order(data.simu$X),]  
  order.idx <- order(survival$err)
  survival <- survival[order.idx,] 
  X <- as.matrix(X[order.idx,])
  #Z <- as.matrix(Z[order.idx,])
  ZXmat <- as.matrix(ZXmat[order.idx,])
  
  #create indicator to set to zero terms where GCT == 0 and 
  #set to 1 so no dividing by zero occurs
  zero.indicator <- 1 * (survival$GCT != 0)
  survival$GCT[which(survival$GCT == 0)] <- 1

  if (is.null(multiplier.wts)) {
    #first col is as.risk.terms, remaining are at.risk.Z.terms
    at.risk.mat <- genIPCWNumDenomMultivar(survival, ZXmat, GC) / n
    
    #generate empty vector to return eventually
    ret.vec <- numeric(nvars)
    for (i in 1:nvars) {
      #return the score   
      ret.vec[i] <- sum(zero.indicator * (survival$delta / survival$GCT) * 
                          (at.risk.mat[,1] * ZXmat[,i] - at.risk.mat[,i + 1])) / sqrt(n)
    }
  } else {
    #first col is as.risk.terms, remaining are at.risk.Z.terms
    at.risk.mat <- genIPCWNumDenomMultivar(survival, ZXmat * multiplier.wts, GC) / n
    
    #generate empty vector to return eventually
    ret.vec <- numeric(nvars)
    for (i in 1:nvars) {
      #return the score   
      ret.vec[i] <- sum(zero.indicator * (survival$delta / survival$GCT) * 
                          (at.risk.mat[,1] * ZXmat[,i] * multiplier.wts - at.risk.mat[,i + 1])) / sqrt(n)
    }
  }
  
  ret.vec
  
}

attr(AFTivIPCWScorePre, "name") <- "AFTivIPCWScorePre"

###############################################
###     Smoothed Estimating Equations       ###
###############################################

AFTivScoreSmoothPre <- function(beta, survival, X, ZXmat, tau = 1e-3)
{ 
  
  #the score function for the AFT model
  
  n <- nrow(X)
  nvars <- ncol(X)
  
  #transform to log-time
  if (is.null(survival$log.t)) {
    log.t <- log(survival$t)
  } else (log.t <- survival$log.t)
  
  delta <- survival$delta
  
  if (n < 10000) {
    #store the T_i - bX_i term (error)
    err = as.vector(log.t - X %*% beta)
    
    #the denominator of the at-risk comparison term  
    out.sig <- sigmoid(outer(err, err, "-"), tau)
    at.risk.terms <- colSums(out.sig)
  } else {
    #store the T_i - bX_i term (error)
    err = log.t - X %*% beta
    
    #the denominator of the at-risk comparison term  
    at.risk.terms <- unlist(lapply(err, function(x) sum(sigmoid((err - x), tau) )))
  }
  #generate empty vector to return eventually
  #   ret.vec <- numeric(nvars)
  #   for (i in 1:nvars) {
  #     #the numerator of the at-risk comparison term 
  #     at.risk.X.terms <- unlist(lapply(survival$err, function(x) 
  #       sum(ZXmat[,i] * sigmoid((survival$err - x), tau))))
  #     
  #     #return the score   
  #     ret.vec[i] <- sum(survival$delta * (survival$at.risk.terms * ZXmat[,i] - at.risk.X.terms)) / sqrt(n)
  #   }
  
  
  if (n < 10000) {
    ret.vec <- apply(ZXmat, 2, function(ZX) {
      at.risk.X.terms <- colSums(out.sig * ZX)
      sum(delta * (at.risk.terms * ZX - at.risk.X.terms)) / sqrt(n)
    })
  } else {
    ret.vec <- apply(ZXmat, 2, function(ZX) {
      at.risk.X.terms <- unlist(lapply(err, function(x) sum(ZX * sigmoid((err - x), tau))))
      sum(delta * (at.risk.terms * ZX - at.risk.X.terms)) / sqrt(n)
    })
  }
  
  ret.vec
}

attr(AFTivScoreSmoothPre, "name") <- "AFTivScoreSmoothPre"

genIPCWNumDenomMultivar <- cmpfun(function(dat, Z, GC.func){
  #dat is a data.frame
  #GC.func is a function
  num.vars <- ncol(Z)
  num <- denom <- array(0, dim = c(nrow(dat),1))
  at.risk.list <- lapply(1:nrow(dat), function(i) {
    err.i <- dat$err[i]
    ind.zero <- F
    ipcw <- GC.func(exp(dat$bX[i:nrow(dat)] + err.i))
    if (all(ipcw == 0)){
      ipcw <- rep(0.01, length(ipcw))
      ind.zero <- T
    }
    ipcw[which(ipcw == 0)] <- min(ipcw[which(ipcw != 0)]) / 2
    ret.vec <- array(0, dim=num.vars+1)
    if (!ind.zero){
      ret.vec[1] <- sum(1 / ipcw)
      for (j in 1:num.vars) {
        ret.vec[j+1] <- sum(Z[i:nrow(dat),j] / ipcw)
      }
      return (ret.vec)
    } else {
      return (ret.vec)
    }
  })
  do.call(rbind, at.risk.list)
})

AFTScoreSmoothPre <- function(beta, survival, X, ZXmat, tau = 1e-3)
{ 
  
  #the score function for the AFT model
  
  n <- nrow(X)
  nvars <- ncol(X)
  
  #transform to log-time
  if (is.null(survival$log.t)) { 
    log.t <- log(survival$t)
  } else (log.t <- survival$log.t)
  
  delta <- survival$delta
  
  if (n < 10000) {
    #store the T_i - bX_i term (error)
    err = as.vector(log.t - X %*% beta)
    
    #the denominator of the at-risk comparison term  
    out.sig <- sigmoid(outer(err, err, "-"), tau)
    at.risk.terms <- colSums(out.sig) / n
  } else {
    #store the T_i - bX_i term (error)
    err = log.t - X %*% beta
    
    #the denominator of the at-risk comparison term  
    at.risk.terms <- unlist(lapply(err, function(x) sum(sigmoid((err - x), tau) ))) / n
  }
  # #generate empty vector to return eventually
  #   ret.vec <- numeric(nvars)
  #   for (i in 1:nvars) {
  #     #the numerator of the at-risk comparison term 
  #     at.risk.X.terms <- unlist(lapply(err, function(x) sum(X[,i] * sigmoid((err - x), tau))))
  #     
  #     #return the score   
  #     ret.vec[i] <- sum(delta * (at.risk.terms * X[,i] - at.risk.X.terms)) / sqrt(n)
  #   }
  if (n < 10000) {
    ret.vec <- apply(X, 2, function(xi) {
      at.risk.X.terms <- colSums(out.sig * xi) / n
      sum(delta * (at.risk.terms * xi - at.risk.X.terms)) / sqrt(n)
    })
  } else {
    ret.vec <- apply(X, 2, function(xi) {
      at.risk.X.terms <- unlist(lapply(err, function(x) sum(xi * sigmoid((err - x), tau)))) / n
      sum(delta * (at.risk.terms * xi - at.risk.X.terms)) / sqrt(n)
    })
  }
  
  ret.vec
}

attr(AFTScoreSmoothPre, "name") <- "AFTScoreSmoothPre"
